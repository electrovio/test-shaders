<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voronoi Colors</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #fff;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            color: #000;
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            z-index: 10;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        }
        
        .control-group {
            margin-bottom: 16px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            font-weight: 400;
            color: #000;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #000;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #000;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            margin-right: 8px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
        }
        
        .checkbox-group label {
            margin-bottom: 0;
        }
        
        .value {
            float: right;
            font-size: 12px;
            color: #666;
            font-weight: 400;
        }
        
        h3 {
            margin-bottom: 16px;
            font-size: 16px;
            font-weight: 600;
            color: #000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <h3>Voronoi Colors</h3>
        
        <div class="control-group">
            <label>
                Cell Count
                <span class="value" id="scaleValue">9</span>
            </label>
            <input type="range" id="scale" min="2" max="80" step="1" value="9">
        </div>
        
        <div class="control-group">
            <label>
                Animation Speed
                <span class="value" id="speedValue">0.15</span>
            </label>
            <input type="range" id="speed" min="0" max="1" step="0.05" value="0.15">
        </div>
        
        <div class="control-group">
            <label>
                Morph Amount
                <span class="value" id="amplitudeValue">0.75</span>
            </label>
            <input type="range" id="amplitude" min="0" max="0.8" step="0.05" value="0.75">
        </div>
        
        <div class="control-group">
            <label>
                Motion Smoothness
                <span class="value" id="smoothnessValue">1.0</span>
            </label>
            <input type="range" id="smoothness" min="0.5" max="3" step="0.1" value="1.0">
        </div>
        
        <div class="control-group">
            <label>
                Wave Strength
                <span class="value" id="waveValue">0.40</span>
            </label>
            <input type="range" id="wave" min="0" max="1" step="0.05" value="0.40">
        </div>
        
        <div class="control-group">
            <label>
                Border Thickness
                <span class="value" id="borderValue">0.10</span>
            </label>
            <input type="range" id="border" min="0.01" max="0.1" step="0.01" value="0.10">
        </div>
        
        <div class="control-group">
            <div class="checkbox-group">
                <input type="checkbox" id="animate" checked>
                <label for="animate">Animate Cells</label>
            </div>
        </div>
        
        <div class="control-group">
            <div class="checkbox-group">
                <input type="checkbox" id="circular">
                <label for="circular">Circular Motion</label>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL not supported in your browser');
            throw new Error('WebGL not supported');
        }

        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            uniform vec2 iResolution;
            uniform float iTime;
            uniform float uScale;
            uniform float uSpeed;
            uniform float uAmplitude;
            uniform float uSmoothness;
            uniform float uWave;
            uniform float uBorder;
            uniform bool uAnimate;
            uniform bool uCircular;

            // Hash function for pseudo-random
            vec2 hash2(vec2 p) {
                p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
                return fract(sin(p) * 43758.5453);
            }

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            // Color palette: Blue, White, Yellow, Magenta
            vec3 getColor(float id) {
                // Use cell ID to pick a color from our palette
                float colorIndex = mod(id * 4.0, 4.0);
                
                if (colorIndex < 1.0) {
                    // Blue
                    return vec3(0.27, 0.51, 0.98); // #4583FA
                } else if (colorIndex < 2.0) {
                    // White
                    return vec3(0.95, 0.95, 0.95);
                } else if (colorIndex < 3.0) {
                    // Yellow
                    return vec3(1.0, 0.98, 0.0); // #FFFA00
                } else {
                    // Magenta
                    return vec3(1.0, 0.22, 0.63); // #FF38A0
                }
            }

            // Voronoi pattern
            vec3 voronoi(vec2 uv) {
                vec2 cell = floor(uv);
                vec2 localPos = fract(uv);
                
                float minDist1 = 1.0;
                float minDist2 = 1.0;
                vec2 closestCell;
                
                // Check current cell and all neighbors
                for (int y = -1; y <= 1; y++) {
                    for (int x = -1; x <= 1; x++) {
                        vec2 neighbor = vec2(float(x), float(y));
                        vec2 neighborCell = cell + neighbor;
                        
                        // Point within cell
                        vec2 point = hash2(neighborCell);
                        
                        // Add animation with refined controls
                        if (uAnimate) {
                            float timeOffset = point.x * 6.28 + point.y * 3.14;
                            
                            // Add wave pattern influence
                            vec2 cellWorldPos = neighborCell / uScale;
                            float waveInfluence = 0.0;
                            if (uWave > 0.0) {
                                // Create traveling wave across the entire grid
                                waveInfluence = sin(cellWorldPos.x * 3.14 + cellWorldPos.y * 2.0 + iTime * uSpeed * 2.0) * uWave;
                            }
                            
                            vec2 motion = vec2(0.0);
                            
                            if (uCircular) {
                                // Circular motion
                                float angle = iTime * uSpeed + timeOffset + waveInfluence * 3.14;
                                motion = vec2(cos(angle * uSmoothness), sin(angle * uSmoothness));
                            } else {
                                // Back-and-forth motion with wave coordination
                                motion = sin(iTime * uSpeed + vec2(timeOffset, timeOffset * 1.3) * uSmoothness + waveInfluence);
                            }
                            
                            // Apply motion with amplitude
                            // Keep motion small to avoid wrapping issues
                            point += uAmplitude * motion * 0.9;
                            
                            // Smooth clamping instead of fract() to prevent jumping
                            // This keeps points within [0,1] without sudden wraps
                            point = clamp(point, 0.05, 0.95);
                        }
                        
                        vec2 diff = neighbor + point - localPos;
                        float dist = length(diff);
                        
                        if (dist < minDist1) {
                            minDist2 = minDist1;
                            minDist1 = dist;
                            closestCell = neighborCell;
                        } else if (dist < minDist2) {
                            minDist2 = dist;
                        }
                    }
                }
                
                // Edge detection (distance between closest and second closest)
                float edge = minDist2 - minDist1;
                
                // Cell ID for coloring
                float cellId = hash(closestCell);
                
                return vec3(minDist1, edge, cellId);
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / iResolution.xy;
                vec2 scaledUV = uv * uScale;
                scaledUV.x *= iResolution.x / iResolution.y; // Aspect ratio
                
                // Get Voronoi data
                vec3 vor = voronoi(scaledUV);
                float dist = vor.x;
                float edge = vor.y;
                float cellId = vor.z;
                
                // Get cell color from palette
                vec3 cellColor = getColor(cellId);
                
                // Draw black border at cell edges
                float borderLine = smoothstep(uBorder + 0.01, uBorder, edge);
                
                // Mix cell color with black border
                vec3 col = mix(cellColor, vec3(0.0), borderLine);
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        const uniforms = {
            iResolution: gl.getUniformLocation(program, 'iResolution'),
            iTime: gl.getUniformLocation(program, 'iTime'),
            uScale: gl.getUniformLocation(program, 'uScale'),
            uSpeed: gl.getUniformLocation(program, 'uSpeed'),
            uAmplitude: gl.getUniformLocation(program, 'uAmplitude'),
            uSmoothness: gl.getUniformLocation(program, 'uSmoothness'),
            uWave: gl.getUniformLocation(program, 'uWave'),
            uBorder: gl.getUniformLocation(program, 'uBorder'),
            uAnimate: gl.getUniformLocation(program, 'uAnimate'),
            uCircular: gl.getUniformLocation(program, 'uCircular'),
        };

        let params = {
            scale: 9,
            speed: 0.15,
            amplitude: 0.75,
            smoothness: 1.0,
            wave: 0.40,
            border: 0.10,
            animate: true,
            circular: false,
        };

        const controls = {
            scale: document.getElementById('scale'),
            speed: document.getElementById('speed'),
            amplitude: document.getElementById('amplitude'),
            smoothness: document.getElementById('smoothness'),
            wave: document.getElementById('wave'),
            border: document.getElementById('border'),
            animate: document.getElementById('animate'),
            circular: document.getElementById('circular'),
        };

        const values = {
            scale: document.getElementById('scaleValue'),
            speed: document.getElementById('speedValue'),
            amplitude: document.getElementById('amplitudeValue'),
            smoothness: document.getElementById('smoothnessValue'),
            wave: document.getElementById('waveValue'),
            border: document.getElementById('borderValue'),
        };

        controls.scale.addEventListener('input', (e) => {
            params.scale = parseInt(e.target.value);
            values.scale.textContent = params.scale;
        });

        controls.speed.addEventListener('input', (e) => {
            params.speed = parseFloat(e.target.value);
            values.speed.textContent = params.speed.toFixed(2);
        });

        controls.amplitude.addEventListener('input', (e) => {
            params.amplitude = parseFloat(e.target.value);
            values.amplitude.textContent = params.amplitude.toFixed(2);
        });

        controls.smoothness.addEventListener('input', (e) => {
            params.smoothness = parseFloat(e.target.value);
            values.smoothness.textContent = params.smoothness.toFixed(1);
        });

        controls.wave.addEventListener('input', (e) => {
            params.wave = parseFloat(e.target.value);
            values.wave.textContent = params.wave.toFixed(2);
        });

        controls.border.addEventListener('input', (e) => {
            params.border = parseFloat(e.target.value);
            values.border.textContent = params.border.toFixed(2);
        });

        controls.animate.addEventListener('change', (e) => {
            params.animate = e.target.checked;
        });

        controls.circular.addEventListener('change', (e) => {
            params.circular = e.target.checked;
        });

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resize);
        resize();

        const startTime = Date.now();

        function render() {
            const currentTime = (Date.now() - startTime) / 1000;

            gl.useProgram(program);
            
            gl.uniform2f(uniforms.iResolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.iTime, currentTime);
            gl.uniform1f(uniforms.uScale, params.scale);
            gl.uniform1f(uniforms.uSpeed, params.speed);
            gl.uniform1f(uniforms.uAmplitude, params.amplitude);
            gl.uniform1f(uniforms.uSmoothness, params.smoothness);
            gl.uniform1f(uniforms.uWave, params.wave);
            gl.uniform1f(uniforms.uBorder, params.border);
            gl.uniform1i(uniforms.uAnimate, params.animate ? 1 : 0);
            gl.uniform1i(uniforms.uCircular, params.circular ? 1 : 0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
